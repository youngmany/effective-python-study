"""
많은 함수를 동시에 실행하려면 코루틴을 고려하자

파이썬은 스레드를 이용하여 여러 기능을 동시에 실행하는 것처럼 보여줄 수 있다.
하지만 스레드를 사용하는데는 크게 세가지 문제가 있다.

1.스레드들이 서로 안전하게 동작하도록 조율하려면 특별한 도구가 필요하다.
따라서 스레드를 사용하는 코드가 절차적인 싱글 스레드 코드보다 이해하기 어렵다.
즉, 확장하거나 유지보수하기 힘들다
2.스레드에는 메모리가 많이 필요하다(스레드당 약 8MB)
그렇기에 함수 수천 개를 동시에 실행한다면 제대로 동작하지 않을 수 있다.
3.스레드를 시작하는 데는 비용이 많이 든다. 끊임없이 새 병행 함수를 생성하고 종료하면 스레드를 사용하면서 드는 부하가
커져서 전체 시스템이 느려진다.

파이썬에서는 코루틴으로 이런 문제를 모두 해결한다. 코루틴을 이용하면 파이썬 프로그램에서 동시에 많은 함수를
실행하는 것처럼 보이게 할 수 있다. 코루틴은 제너레이터를 확장하는 방법으로 구현하며 제너레이터 코루틴을 시작하는데
드는 비용은 함수 호출이다.

코루틴은 제너레이터를 소비하는 코드에서 send 함수를 사용하여 역으로 제너레이터 함수의 각 yield 표현식에 값을
보낼 수 있게 하는 방법으로 동작한다.
"""


def my_coroutine():
    while True:
        received = yield
        print('Received:', received)


it = my_coroutine()
next(it)
it.send('First')
it.send('Second')

"""
제너레이터가 첫 번째 yield 표현식으로 전진해서 첫 번째 send의 값을 받을 수 있게 하려면
먼저 next를 호출해야한다. yield와 send의 조합은 제너레이터가 외부 입력에 반응하여 다음번에 다른 값을 얻게
하는 표준 방법이다.

예를 들어 지금가지 보낸 값 중에서 최솟값을 넘겨주는 제너레이터 코루틴을 구현한다고 하자. 여기서는 넘길 값이 없는
yield로 외부에서 보낸 초기 최솟값을 받아서 코루틴을 준비한다. 이후 제너레이터는 반복적으로 다음 값을 받으면서
새 최솟값을 넘겨준다.
"""


def minimize():
    current = yield
    print(current)
    while True:
        print(1)
        value = yield current
        print(value, 'i')
        current = min(value, current)


it = minimize()
next(it)
print(it.send(10))
print(it.send(40))
#print(it.send(2))

"""
제너레이터 함수는 send를 새로 호출 할 때마다 전진하면서 계속 실행하는것 처럼 보인다.
스레드와 마찬가지로 코루틴은 주변 환경에서 받은 입력을 소비하여 결과를 만들어낼 수 있는
독립적인 함수다. 둘의 차이는 코루틴이 제너레이터 함수의 yield 표현식에서 멈췄다가 
send를 호출할 때 마다 다시 시작한다는 점이다.

중요한건 제너레이터 함수들을 yield 표현식 이전까지 전진시킬 수 있다는 점이다.
많은 별개의 제너레이터를 똑같은 방식으로 실행하면, 이 제너레이터들이 스레드의 병행 동작을 흉내 내며 동시에 실행하는
것처럼 보인다.
"""


